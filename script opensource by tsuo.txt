-- ESP + linha até outros jogadores (LocalScript)
-- Coloque este LocalScript em StarterPlayerScripts
-- Uso: educativo / debugging. Não use para trapacear em jogos multiplayer.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- Configurações
local BOX_COLOR = Color3.fromRGB(255, 0, 0)
local BOX_THICKNESS = 2
local LINE_COLOR = Color3.fromRGB(0, 255, 0)
local LINE_THICKNESS = 2
local WIDTH_RELATION_TO_HEIGHT = 0.5 -- largura da caixa = altura * fator

-- GUI raiz
local playerGui = LocalPlayer:WaitForChild("PlayerGui")
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ESP_and_Lines"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

-- Armazenamento de GUIs por player
local guiMap = {}

-- Cria elementos GUI para um jogador
local function createGuiForPlayer(player)
	if guiMap[player] then return end

	local folder = Instance.new("Folder")
	folder.Name = player.Name
	folder.Parent = screenGui

	-- Caixa: usaremos 4 frames finos (top, bottom, left, right)
	local top = Instance.new("Frame")
	top.Name = "Top"
	top.BackgroundColor3 = BOX_COLOR
	top.BorderSizePixel = 0
	top.Size = UDim2.new(0, 0, 0, BOX_THICKNESS)
	top.Visible = false
	top.Parent = folder

	local bottom = top:Clone()
	bottom.Name = "Bottom"
	bottom.Parent = folder

	local left = Instance.new("Frame")
	left.Name = "Left"
	left.BackgroundColor3 = BOX_COLOR
	left.BorderSizePixel = 0
	left.Size = UDim2.new(0, BOX_THICKNESS, 0, 0)
	left.Visible = false
	left.Parent = folder

	local right = left:Clone()
	right.Name = "Right"
	right.Parent = folder

	-- Linha do meu personagem até o outro jogador
	local line = Instance.new("Frame")
	line.Name = "Line"
	line.BackgroundColor3 = LINE_COLOR
	line.BorderSizePixel = 0
	line.Size = UDim2.new(0, 0, 0, LINE_THICKNESS)
	line.Visible = false
	line.AnchorPoint = Vector2.new(0, 0.5) -- começará no ponto inicial, central verticalmente
	line.Parent = folder

	guiMap[player] = {
		folder = folder,
		top = top,
		bottom = bottom,
		left = left,
		right = right,
		line = line,
		visible = false
	}
end

local function removeGuiForPlayer(player)
	local entry = guiMap[player]
	if entry then
		if entry.folder and entry.folder.Parent then
			entry.folder:Destroy()
		end
		guiMap[player] = nil
	end
end

-- Atualiza posição/visibilidade das GUIs
local function updateGuiForPlayer(player, dt)
	local entry = guiMap[player]
	if not entry then return end

	local character = player.Character
	if not character then
		-- esconder se sem personagem
		entry.top.Visible = false
		entry.bottom.Visible = false
		entry.left.Visible = false
		entry.right.Visible = false
		entry.line.Visible = false
		return
	end

	local head = character:FindFirstChild("Head") or character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")
	local root = character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
	if not head or not root then
		entry.top.Visible = false
		entry.bottom.Visible = false
		entry.left.Visible = false
		entry.right.Visible = false
		entry.line.Visible = false
		return
	end

	-- Posições em tela
	local headPos3, headOnScreen = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 0.3, 0))
	local rootPos3, rootOnScreen = Camera:WorldToViewportPoint(root.Position)
	-- Se nenhuma parte visível, esconder
	if not headOnScreen and not rootOnScreen then
		entry.top.Visible = false
		entry.bottom.Visible = false
		entry.left.Visible = false
		entry.right.Visible = false
		entry.line.Visible = false
		return
	end

	local topX, topY = headPos3.X, headPos3.Y
	local bottomX, bottomY = rootPos3.X, rootPos3.Y

	-- Evitar valores NaN
	if not topX or not topY or not bottomX or not bottomY then
		entry.top.Visible = false
		entry.bottom.Visible = false
		entry.left.Visible = false
		entry.right.Visible = false
		entry.line.Visible = false
		return
	end

	local height = math.abs(bottomY - topY)
	if height < 10 then height = 10 end
	local width = math.max( math.floor(height * WIDTH_RELATION_TO_HEIGHT), 10 )

	-- Calcular canto superior esquerdo da caixa
	local leftX = topX - (width / 2)
	local topYpos = topY

	-- Aplicar à GUI (frames)
	entry.top.Position = UDim2.new(0, leftX, 0, topYpos)
	entry.top.Size = UDim2.new(0, width, 0, BOX_THICKNESS)
	entry.top.Visible = true

	entry.bottom.Position = UDim2.new(0, leftX, 0, topYpos + height - BOX_THICKNESS)
	entry.bottom.Size = UDim2.new(0, width, 0, BOX_THICKNESS)
	entry.bottom.Visible = true

	entry.left.Position = UDim2.new(0, leftX, 0, topYpos)
	entry.left.Size = UDim2.new(0, BOX_THICKNESS, 0, height)
	entry.left.Visible = true

	entry.right.Position = UDim2.new(0, leftX + width - BOX_THICKNESS, 0, topYpos)
	entry.right.Size = UDim2.new(0, BOX_THICKNESS, 0, height)
	entry.right.Visible = true

	-- Linha do meu personagem até o outro
	local myChar = LocalPlayer.Character
	local myRoot = myChar and (myChar:FindFirstChild("HumanoidRootPart") or myChar.PrimaryPart)
	local myHead = myChar and (myChar:FindFirstChild("Head") or myChar:FindFirstChild("UpperTorso"))
	if myRoot and (myHead or myRoot) then
		-- usar cabeça se possível, senão root
		local myPosWorld = (myHead and myHead.Position) or myRoot.Position
		local myScreen3, myOnScreen = Camera:WorldToViewportPoint(myPosWorld)
		local targetScreen3, targetOnScreen = Camera:WorldToViewportPoint(head.Position)
		if myOnScreen and targetOnScreen then
			local sx, sy = myScreen3.X, myScreen3.Y
			local tx, ty = targetScreen3.X, targetScreen3.Y
			local dx = tx - sx
			local dy = ty - sy
			local dist = math.sqrt(dx*dx + dy*dy)
			-- Atualiza linha
			entry.line.Position = UDim2.new(0, sx, 0, sy)
			entry.line.Size = UDim2.new(0, dist, 0, LINE_THICKNESS)
			-- Rotação em graus (frame tem propriedade Rotation)
			local angle = math.deg(math.atan2(dy, dx))
			-- Rotation existe em GuiObject, se não existir, esconder fallback
			if entry.line.Rotation ~= nil then
				entry.line.Rotation = angle
				entry.line.Visible = true
			else
				-- fallback: não dá para girar -> esconder para evitar GUI estranha
				entry.line.Visible = false
			end
		else
			entry.line.Visible = false
		end
	else
		entry.line.Visible = false
	end
end

-- Configura novos players que entrarem
local function onPlayerAdded(player)
	createGuiForPlayer(player)
	-- quando personagem aparecer, apenas garantir que gui exista
	player.CharacterAdded:Connect(function()
		createGuiForPlayer(player)
	end)
end

local function onPlayerRemoving(player)
	removeGuiForPlayer(player)
end

-- Inicializar para jogadores já presentes
for _, p in pairs(Players:GetPlayers()) do
	if p ~= LocalPlayer then
		onPlayerAdded(p)
	end
end

Players.PlayerAdded:Connect(function(p)
	if p ~= LocalPlayer then
		onPlayerAdded(p)
	end
end)
Players.PlayerRemoving:Connect(onPlayerRemoving)

-- Atualização por frame
RunService:BindToRenderStep("ESP_Update", Enum.RenderPriority.Camera.Value + 1, function(dt)
	for player, entry in pairs(guiMap) do
		-- garantir que não ultrapasse o localplayer
		if player ~= LocalPlayer then
			-- se player não mais existe, limpar
			if not player.Parent then
				removeGuiForPlayer(player)
			else
				updateGuiForPlayer(player, dt)
			end
		end
	end
end)

-- Limpar ao morrer / reaparecer do local player
LocalPlayer.CharacterAdded:Connect(function()
	-- nada especial por enquanto
end)
